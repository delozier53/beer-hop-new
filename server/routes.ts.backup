import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { 
  insertChallengeSchema, 
  insertUserChallengeSchema, 
  insertUserStatsSchema 
} from "@shared/schema";

export async function registerRoutes(app: Express): Promise<Server> {
  // Existing routes... (keeping all the current functionality)

  // Challenge System Routes
  
  // Get all challenges
  app.get("/api/challenges", async (req, res) => {
    try {
      const challenges = await storage.getChallenges();
      res.json(challenges);
    } catch (error) {
      console.error("Error fetching challenges:", error);
      res.status(500).json({ error: "Failed to fetch challenges" });
    }
  });

  // Get active challenges only
  app.get("/api/challenges/active", async (req, res) => {
    try {
      const challenges = await storage.getActiveChallenges();
      res.json(challenges);
    } catch (error) {
      console.error("Error fetching active challenges:", error);
      res.status(500).json({ error: "Failed to fetch active challenges" });
    }
  });

  // Get specific challenge
  app.get("/api/challenges/:id", async (req, res) => {
    try {
      const challenge = await storage.getChallenge(req.params.id);
      if (!challenge) {
        return res.status(404).json({ error: "Challenge not found" });
      }
      res.json(challenge);
    } catch (error) {
      console.error("Error fetching challenge:", error);
      res.status(500).json({ error: "Failed to fetch challenge" });
    }
  });

  // Create new challenge (admin only)
  app.post("/api/challenges", async (req, res) => {
    try {
      const challengeData = insertChallengeSchema.parse(req.body);
      const challenge = await storage.createChallenge(challengeData);
      res.status(201).json(challenge);
    } catch (error) {
      console.error("Error creating challenge:", error);
      res.status(500).json({ error: "Failed to create challenge" });
    }
  });

  // Update challenge (admin only)
  app.patch("/api/challenges/:id", async (req, res) => {
    try {
      const updates = req.body;
      const challenge = await storage.updateChallenge(req.params.id, updates);
      if (!challenge) {
        return res.status(404).json({ error: "Challenge not found" });
      }
      res.json(challenge);
    } catch (error) {
      console.error("Error updating challenge:", error);
      res.status(500).json({ error: "Failed to update challenge" });
    }
  });

  // Delete challenge (admin only)
  app.delete("/api/challenges/:id", async (req, res) => {
    try {
      const success = await storage.deleteChallenge(req.params.id);
      if (!success) {
        return res.status(404).json({ error: "Challenge not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting challenge:", error);
      res.status(500).json({ error: "Failed to delete challenge" });
    }
  });

  // User Challenge Routes

  // Get user's challenges
  app.get("/api/users/:userId/challenges", async (req, res) => {
    try {
      const userChallenges = await storage.getUserChallenges(req.params.userId);
      res.json(userChallenges);
    } catch (error) {
      console.error("Error fetching user challenges:", error);
      res.status(500).json({ error: "Failed to fetch user challenges" });
    }
  });

  // Join a challenge
  app.post("/api/users/:userId/challenges/:challengeId/join", async (req, res) => {
    try {
      const userChallenge = await storage.joinChallenge(req.params.userId, req.params.challengeId);
      res.status(201).json(userChallenge);
    } catch (error) {
      console.error("Error joining challenge:", error);
      res.status(500).json({ error: "Failed to join challenge" });
    }
  });

  // Update challenge progress
  app.patch("/api/users/:userId/challenges/:challengeId/progress", async (req, res) => {
    try {
      const { progress, data } = req.body;
      const userChallenge = await storage.updateUserChallengeProgress(
        req.params.userId, 
        req.params.challengeId, 
        progress, 
        data
      );
      if (!userChallenge) {
        return res.status(404).json({ error: "User challenge not found" });
      }
      res.json(userChallenge);
    } catch (error) {
      console.error("Error updating challenge progress:", error);
      res.status(500).json({ error: "Failed to update challenge progress" });
    }
  });

  // Complete a challenge
  app.post("/api/users/:userId/challenges/:challengeId/complete", async (req, res) => {
    try {
      const userChallenge = await storage.completeUserChallenge(req.params.userId, req.params.challengeId);
      if (!userChallenge) {
        return res.status(404).json({ error: "User challenge not found" });
      }
      res.json(userChallenge);
    } catch (error) {
      console.error("Error completing challenge:", error);
      res.status(500).json({ error: "Failed to complete challenge" });
    }
  });

  // User Stats Routes

  // Get user stats
  app.get("/api/users/:userId/stats", async (req, res) => {
    try {
      const stats = await storage.getUserStats(req.params.userId);
      if (!stats) {
        return res.status(404).json({ error: "User stats not found" });
      }
      res.json(stats);
    } catch (error) {
      console.error("Error fetching user stats:", error);
      res.status(500).json({ error: "Failed to fetch user stats" });
    }
  });

  // Update user stats
  app.patch("/api/users/:userId/stats", async (req, res) => {
    try {
      const updates = req.body;
      const stats = await storage.updateUserStats(req.params.userId, updates);
      if (!stats) {
        return res.status(404).json({ error: "User stats not found" });
      }
      res.json(stats);
    } catch (error) {
      console.error("Error updating user stats:", error);
      res.status(500).json({ error: "Failed to update user stats" });
    }
  });

  // Challenge Leaderboard Routes

  // Get challenge leaderboard
  app.get("/api/challenges/:challengeId/leaderboard", async (req, res) => {
    try {
      const leaderboard = await storage.getChallengeLeaderboard(req.params.challengeId);
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching challenge leaderboard:", error);
      res.status(500).json({ error: "Failed to fetch challenge leaderboard" });
    }
  });

  // Update leaderboard entry
  app.post("/api/challenges/:challengeId/leaderboard", async (req, res) => {
    try {
      const { userId, score } = req.body;
      await storage.updateChallengeLeaderboard(req.params.challengeId, userId, score);
      res.json({ success: true });
    } catch (error) {
      console.error("Error updating challenge leaderboard:", error);
      res.status(500).json({ error: "Failed to update challenge leaderboard" });
    }
  });

  // Enhanced check-in route that processes challenges
  app.post("/api/checkins", async (req, res) => {
    try {
      const checkInData = req.body;
      
      // Create the check-in
      const checkIn = await storage.createCheckIn(checkInData);
      
      // Process challenge progress for this check-in
      await processCheckInChallenges(checkInData.userId, checkInData.breweryId);
      
      res.status(201).json(checkIn);
    } catch (error) {
      console.error("Error creating check-in:", error);
      res.status(500).json({ error: "Failed to create check-in" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

// Helper function to process challenge progress when user checks in
async function processCheckInChallenges(userId: string, breweryId: string) {
  try {
    // Get user's active challenges
    const userChallenges = await storage.getUserChallenges(userId);
    const activeChallenges = userChallenges.filter(uc => uc.status === 'active');
    
    for (const userChallenge of activeChallenges) {
      const challenge = await storage.getChallenge(userChallenge.challengeId);
      if (!challenge) continue;
      
      let updatedProgress = userChallenge.progress;
      let challengeData = userChallenge.data || {};
      
      switch (challenge.type) {
        case 'variety':
          // Track unique breweries visited
          const visitedBreweries = challengeData.visitedBreweries || [];
          if (!visitedBreweries.includes(breweryId)) {
            visitedBreweries.push(breweryId);
            challengeData.visitedBreweries = visitedBreweries;
            updatedProgress = visitedBreweries.length;
          }
          break;
          
        case 'time':
          // Track check-ins within time period
          const now = new Date();
          const timeWindow = challenge.timeLimit || 7; // days
          const windowStart = new Date(now.getTime() - (timeWindow * 24 * 60 * 60 * 1000));
          
          // Count recent check-ins (this would need to query actual check-ins)
          updatedProgress = userChallenge.progress + 1;
          challengeData.lastVisitDate = now.toISOString();
          break;
          
        case 'social':
          // This would be updated when user shares
          break;
          
        case 'distance':
          // Calculate distance traveled (would need user location tracking)
          break;
      }
      
      // Update progress
      if (updatedProgress !== userChallenge.progress) {
        await storage.updateUserChallengeProgress(userId, challenge.id, updatedProgress, challengeData);
        
        // Check if challenge is completed
        if (updatedProgress >= challenge.targetValue) {
          await storage.completeUserChallenge(userId, challenge.id);
        }
      }
    }
  } catch (error) {
    console.error("Error processing check-in challenges:", error);
  }
}